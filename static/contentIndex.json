{"02_Nodes/Linux-IO-IO类型详解":{"slug":"02_Nodes/Linux-IO-IO类型详解","filePath":"02_Nodes/Linux-IO-IO类型详解.md","title":"Linux IO类型详解","links":[],"tags":["linux","io","存储"],"content":"基本信息\n阅读信息\n最后更新: 2026-01-28\r\n关键词: #Linux #存储 #IO #性能优化\n\n目录\n\n背景\nLinux IO类型\n\nBuffered IO\nDirect IO\n\n\n实际应用建议\n总结\n扩展阅读\n\nLinux IO类型\nLinux主要有两种IO类型：Buffered IO和Direct IO。\nBuffered IO(标准IO)\n数据路径\ndisk → kernel page cache → user buffer\n\n工作原理：\r\n数据先从磁盘读到内核的页缓存(page cache)，然后再从页缓存复制到用户缓冲区(user buffer)。\n特点：\n\n双重拷贝：数据需要复制两次，所以性能相对较低🥺\n缓存优势：适合频繁读取相同数据的场景\n操作系统友好：内核可以更好地管理缓存\n数据一致性：需要注意缓存同步问题\n\n应用场景：适合大多数常规文件操作。比如编辑文档、运行普通程序等日常任务\nDirect IO(直接IO)\n数据路径\ndisk → DMA → user buffer\n\n工作原理：\r\n数据直接从磁盘通过DMA(Direct Memory Access)传输到用户缓冲区，绕过内核页缓存！\n特点：\n\n高性能：只有一次数据拷贝，速度更快\n内存对齐要求：需要保持内存对齐(Memory Alignment)\n大数据友好：适合处理大文件或数据库\n编程复杂度：需要更多的手动管理😢\n\n使用Direct IO的条件：\n\n内存对齐：缓冲区地址和大小必须是块大小的整数倍\n同步操作：通常需要配合同步IO使用\n大文件操作：最适合处理大型数据文件\n\n实际应用建议\n根据不同场景选择合适的IO类型是关键。下面是一些常见场景的推荐：\n普通文件读写\n\n推荐：Buffered IO\n理由：操作系统缓存能提高性能\n\n数据库系统\n\n推荐：Direct IO\n理由：避免双重缓存，提高一致性\n\n视频处理\n\n推荐：Direct IO\n理由：大文件连续读写效率高\n\n日志文件\n\n推荐：Buffered IO\n理由：小文件频繁写入，缓存友好\n\n总结\n\nBuffered IO：安全稳定，适合通用场景，有缓存加成\nDirect IO：性能强大，适合专业场景，需要更多配置\n\n两种IO各有优劣，关键是根据应用需求选择对的工具✌️。\n扩展阅读\n\nLinux man pages: open()系统调用 - 看O_DIRECT标志的详细说明\nUnderstanding Direct I/O - LWN上的深度解析\nLinux Performance - Brendan Gregg的性能优化指南\n\n"},"02_Nodes/index":{"slug":"02_Nodes/index","filePath":"02_Nodes/index.md","title":"学习笔记","links":[],"tags":["个人","博客"],"content":"这里是学习笔记\n"},"02_Nodes/robot工具箱":{"slug":"02_Nodes/robot工具箱","filePath":"02_Nodes/robot工具箱.md","title":"robot工具箱","links":[],"tags":["robotics","matlab","工具箱"],"content":"Robotics Toolbox for MATLAB 函数指南\n本指南整理了 Robotics Toolbox for MATLAB 中核心函数及类的作用，帮助初学者快速了解其功能和应用场景。\n\n\n🚗 导航与路径规划\n1. Astar 类\n\n作用: 实现 A* 路径规划算法，用于静态环境中的最短路径搜索。\n特点: 支持多目标优化 (MOO) 和 Pareto 最优性 (AstarPO)。\n方法: plan() 计算路径，path() 生成路径，plot() 可视化地图。\n\n2. Dstar 类\n\n作用: 动态路径规划算法，支持增量式重新规划（如环境变化时）。\n变种:\n\nDstarMOO: 多目标优化版本。\nDstarPO: 使用 Pareto 前沿的多目标优化。\n\n\n方法: modify_cost() 修改代价地图，reset() 重置规划器。\n\n3. Bug2 类\n\n作用: 实现 Bug2 避障算法，基于局部传感器信息进行简单路径规划。\n适用场景: 未知或动态环境中的实时避障。\n\n4. PRM 类\n\n作用: 概率路线图 (Probabilistic Roadmap) 算法，用于高维空间的路径规划。\n特点: 通过随机采样构建图结构，适合复杂环境。\n\n\n🤖 机器人模型与控制\n1. Bicycle 类\n\n作用: 模拟自行车模型（阿克曼转向）的车辆运动学。\n功能: 生成控制输入、更新状态、可视化轨迹。\n属性: 车辆长度 (L)、最大转向角 (alphalim)。\n\n2. Unicycle 类\n\n作用: 差速驱动机器人模型（如两轮小车）。\n方法: deriv() 计算状态导数，step() 单步运动模拟。\n\n3. SerialLink 类\n\n作用: 构建串联机械臂模型，支持运动学和动力学计算。\n关键方法:\n\nfkine() 正运动学，ikine() 逆运动学。\njacob0() 计算雅可比矩阵，rne() 逆向动力学。\n\n\n\n4. Quadrotor 类\n\n作用: 四旋翼飞行器动力学模型。\n功能: 模拟推力与力矩控制，生成飞行轨迹。\n\n\n🔧 工具函数\n1. ctraj\n\n作用: 生成笛卡尔空间中的轨迹（两点间的平滑运动）。\n输入: 起始和结束位姿，点数或时间向量。\n输出: 齐次变换矩阵序列。\n\n2. delta2tr\n\n作用: 将微分运动（平移和旋转）转换为齐次变换矩阵。\n应用: 机器人末端微小运动建模。\n\n3. trinterp\n\n作用: 在齐次变换矩阵之间插值，生成连续运动轨迹。\n类型: 线性或球面插值。\n\n4. lspb\n\n作用: 生成梯形速度轨迹（Linear Segment with Parabolic Blends）。\n特点: 平滑加速和减速，避免速度突变。\n\n\n🗺️ 地图与感知\n1. LandmarkMap 类\n\n作用: 地标地图模型，用于 SLAM（同步定位与地图构建）。\n方法: 添加/获取地标，计算观测模型。\n\n2. EKF 类\n\n作用: 扩展卡尔曼滤波器，用于状态估计（如机器人定位）。\n功能: 预测与更新步骤，支持非线性系统模型。\n\n3. distancexform\n\n作用: 计算距离变换图，表示每个点到最近障碍物的距离。\n应用: 路径规划中的代价地图生成。\n\n\n📐 数学与几何工具\n1. SE3 类\n\n作用: 表示三维空间中的刚体变换（旋转+平移）。\n方法:\n\nSE3.transl() 创建平移变换，SE3.rotx() 生成绕 X 轴旋转。\ninterp() 插值变换，log() 计算李代数。\n\n\n\n2. Quaternion 类\n\n作用: 四元数表示三维旋转，避免万向节锁。\n方法:\n\nUnitQuaternion 单位四元数，slerp() 球面线性插值。\n\n\n\n3. Plucker 类\n\n作用: 普吕克坐标表示空间直线，用于几何计算。\n应用: 机器人视觉中的线特征建模。\n\n\n🛠️ 实用工具\n1. rtbdemo\n\n作用: 运行工具箱的演示脚本，快速查看功能示例。\n用法: 在 MATLAB 命令行输入 rtbdemo。\n\n2. startup_rvc\n\n作用: 初始化工具箱路径，确保所有函数可用。\n注意: 安装后首次使用前需执行此脚本。\n\n3. symexpr2slblock\n\n作用: 将符号表达式转换为 Simulink 模块，用于自定义控制算法。\n"},"02_Nodes/机器人学导论":{"slug":"02_Nodes/机器人学导论","filePath":"02_Nodes/机器人学导论.md","title":"机器人学导论","links":[],"tags":["机器人","运动学","机械臂"],"content":"基本信息\n阅读信息\n最后更新: 2025-2-20\n关键词: #运动学\n书目\n《机器人学导论》(introduction to robotics mechanics and control)\n\n目录导航\n\n基本信息\n\n阅读信息\n书目\n\n\n目录导航\n\n核心概念\n\n运动学\n正运动学\n逆运动学\n机械臂自由度\n变换方程\n姿态的X-Y-Z固定角表示法\n姿态的Z-Y-X欧拉角表示法\n姿态的Z-Y-Z欧拉角表示法\n向量的等效与相等（一般说力向量）\n自由向量\n\n\n公式推导\n\n坐标系之间的映射\n\n\n代码实践\n\n环境配置\n\n\n问题记录\n\n部分课后问题\n\n\n扩展阅读\n\n\n\n核心概念\n运动学\n关注物体的运动，不考虑引起物体运动的力。\n通过一个世界坐标系A中的三维向量描述位置。\n通过固定在物体上的坐标系B来描述姿态。\n确定一个由A到B的旋转矩阵_B^AR\n_B^AR=\r\n\\begin{pmatrix}\r\n^A\\hat{X}_B &amp; ^A\\hat{Y}_B &amp; ^A\\hat{Z}_B\r\n\\end{pmatrix}=\r\n\\begin{pmatrix}\r\nr_{11} &amp; r_{12} &amp; r_{13} \\\\\r\n \\\\\r\nr_{21} &amp; r_{22} &amp; r_{23} \\\\\r\n \\\\\r\nr_{31} &amp; r_{32} &amp; r_{33}\r\n\\end{pmatrix}\n则姿态可以由_B^AR确定。\n显然_B^AR是一个正交矩阵，故\n{}_B^AR={}_A^BR^{-1}={}_A^BR^{\\mathrm{T}}\n回想起了古早的线代记忆🤔\n对于一个位姿，需要两部分来同时描述：\n\nB相对A旋转矩阵_B^AR\nB的原点相对A的原点的位置^AP_{BORG}\n故：\r\n\\langle B\\rangle = \\langle_B^AR , ^AP_{BORG} \\rangle\n\n正运动学\n通过关节角的值计算机械臂末端的位置和姿态。\n逆运动学\n通过机械臂末端位置和姿态，计算各个关节角可能的值。\n机械臂自由度\n机械臂中具有独立位置变量的数目。\n变换方程\n通过多个坐标系之间的关系联立方程从而得以推导出其中未知的变换矩阵。\n姿态的X-Y-Z固定角表示法\n旋转矩阵表述一个姿态需要9个变量，但事实上这9个变量并非两两独立。事实上只需要3个变量就可以完整表述一个姿态。\n首先将坐标系A,B原点重合（因为只表示姿态不表示位置🤔）。随后以坐标系A的三个单位向量\\hat{X}_A,\\hat{Y}_A , \\hat{Z}_A方向为基准，按照顺序（先后顺序影响结果），先\\hat{X}_A轴旋转\\gamma，再\\hat{Y}_A轴旋转\\beta，最后\\hat{Z}_A轴旋转\\alpha。即可通过三个角度确定一个姿态。\n姿态的Z-Y-X欧拉角表示法\n结果与X-Y-Z固定角相同，但是旋转顺序和参照的轴不同，参照坐标系B的轴。\n姿态的Z-Y-Z欧拉角表示法\n略\n向量的等效与相等（一般说力向量）\n向量的相等：两个向量具有相同的维数，大小与方向。\n向量的等效：两个向量具有相同的作用效果。\n自由向量\n表示的意义取决于大小与方向。例如力矩或速度，方向不随着参考系变换而变换。\n公式推导\n坐标系之间的映射\n\n仅平移\n\n坐标系B的原点在坐标系A中的表示为^AP_{BORG}。则此时：\n^AP=^BP+^AP_{BORG}\n\n仅旋转\n\n两坐标系原点重合，但是存在旋转，旋转矩阵\n_B^AR=\r\n\\begin{pmatrix}\r\n^A\\hat{X}_B &amp; ^A\\hat{Y}_B &amp; ^A\\hat{Z}_B\r\n\\end{pmatrix}\n而又由旋转矩阵是正交阵，故：\n{}_B^AR={}_A^BR^{-1}={}_A^BR^{\\mathrm{T}}\n对于一个向量，已知其在坐标系B下的表示为^BP，将向量投影在坐标系A\r\n的单位向量方向即可得到该向量在坐标系A中的表示，即：\n^Ap_x=^B\\hat{X}_A\\bullet^BP\n^Ap_y=^B\\hat{Y}_A\\bullet^BP\n^Ap_z=^B\\hat{Z}_A\\bullet^BP  \n也可表述为：\n^AP=_B^AR^BP\n\n同时存在平移与旋转的映射\n\n当坐标系B相对A同时存在平移与旋转时，记B的原点向量为^AP_{BORG}，\r\n旋转向量_B^AR。\n取一个中间坐标系，使得该坐标系原点与B重合，姿态与A相同。首先完成旋转，\r\n然后再平移：\n{}^AP={}_B^AR{}^BP+{}^AP{}_{BORG}\n为了更一般表示：\n\\binom{^AP}{1}=\r\n\\begin{bmatrix}\r\n&amp;{}_{B}^{A}R &amp; &amp; {}^{A}P_{BORG} \\\\\r\n0 &amp; 0 &amp; 0 &amp; 1\r\n\\end{bmatrix}\\binom{BP}{1}\n简写为：\n{}^AP={}_B^AT^BP\n这样写看起了舒服多了😆\n代码实践\n环境配置\n需要matlab的robot工具箱。具体内容见链接中的文档。\n问题记录\n部分课后问题\nQ1：为什么通用机器人最少需要6个关节\nA1：在三维空间中，自由控制机械臂末端的位置和姿态需要6个自由度，分别为三个平移自由度（沿着x、y或z轴平移）和三个旋转自由度（沿着x、y或z轴旋转）。而每个关节通常可以贡献一个自由度，故需要至少6个关节。\n\n扩展阅读"},"03_Projects/Kuro-IO-Phase1-Log":{"slug":"03_Projects/Kuro-IO-Phase1-Log","filePath":"03_Projects/Kuro-IO-Phase1-Log.md","title":"Kuro-IO项目Phase 1开发日志","links":[],"tags":["linux","io","io_uring","性能优化"],"content":"基本信息\n阅读信息\n文章类型: 项目开发日志\n日期: 2026年1月29日\n项目: Kuro-IO\n当前阶段: Phase 1 - 基准测试工具开发\n预计阅读时间: 15分钟\n关键词: #Linux #存储 #IO #性能优化 #io_uring #C语言 #异步IO\n\n目录\n\n项目背景\n核心概念\n\n异步IO模型：io_uring\nio_uring高阶特性\n\n\n工程实现\n\n架构设计：C语言多态\n关键代码细节\n\n\n性能测试与分析\n\n测试环境与参数\n测试结果解读\n\n\n结论与展望\n\n核心结论\n下一步计划\n\n\n\n项目背景\nKuro-IO 是一个开源的存储性能基准测试工具项目，旨在深入探索Linux系统下不同IO模型的实际性能表现。本项目分为多个阶段，Phase 1主要目标是开发一个能够公平对比不同IO模式的基准测试工具（代号”Mini-Bench”）。\n本文作为《[Linux IO类型详解：Buffered vs Direct IO]({{ site.baseurl }}{% post_url 2026-01-28-Linux-IO-Types-Explained %})》的实际应用案例，展示了如何在实际项目中运用这些理论知识，并通过实验验证不同IO模型的性能差异。\n\n核心概念\n异步IO模型：io_uring\n在传统Linux IO模型（如Buffered IO和Direct IO）的基础上，本次重点研究了Linux 5.1+引入的io_uring异步IO框架。\n\nio_uring (Async IO):\n特征: 异步非阻塞，通过 SQ (Submission Queue) 和 CQ (Completion Queue) 传递指令。\n优势: 利用 Queue Depth (QD) 并发掩盖 IO 延迟；单次 Syscall 提交批量请求。\n\nio_uring高阶特性\n\n\nFixed Buffers (IORING_REGISTER_BUFFERS):\n\n\n原理: 启动时将 User Buffer 映射并锁定 (Pin) 在物理内存。\n\n\n收益: 运行时内核不再进行“虚拟地址→物理地址”的转换 (Page Table Walk) 和页面锁定 (get_user_pages)，显著降低 CPU 开销。\n\n\nPolled IO (IORING_SETUP_IOPOLL):\n\n\n原理: CPU 主动轮询 NVMe 队列状态，而非等待硬件中断。\n\n\n收益: 消除中断处理和上下文切换开销，极大降低延迟 (Latency)，但增加 CPU 使用率。\n\n\n\n工程实现\n架构设计：C语言多态\n为了在同一工具中公平对比不同 IO 模式，采用了面向对象风格的接口抽象：\ntypedef struct {\n    const char *name;\n    int (*init)(const char *filename);\n    int (*run_batch)(int fd, void *buf, off_t offset, int count);\n    void (*cleanup)(int fd);\n} EngineOps;\n \n实现了三个后端：ops_buffered, ops_direct, ops_uring。\n关键代码细节\n\n预分配文件 (fallocate): 避免压测过程中因文件系统元数据更新造成的性能抖动。\nUser Data 关联 (io_uring_sqe_set_data64): 在异步请求中保存上下文 (Index/指针)，用于在 CQE 返回时识别请求身份。\n内存对齐: 强制使用 posix_memalign 分配 4K 对齐内存，满足 DMA 硬件要求。\nCQ 收割循环: 在 Batch Submit 后，必须显式消费 CQE (io_uring_cqe_seen)，否则会导致队列溢出。\n\n\n\n性能测试与分析\n测试环境与参数\n环境: WSL2 (限制了绝对性能，但验证了相对比例)\n负载: 1GB 顺序写, 4KB Block, QD=64\n\n\nBuffered IO (标准 IO)\n\n\n数据： 148.9k IOPS | 581.5 MB/s\n\n\n解读： 虚假繁荣。数据仅写入 Page Cache (RAM)，未真正落盘。这展示的是系统调用的极限速度，而非磁盘速度。\n\n\nDirect IO (同步直写)\n\n\n数据： 6.5k IOPS | 25.5 MB/s\n\n\n解读： 物理真相。受限于同步阻塞和单线程模型，性能完全被单次 IO 的物理延迟锁死（）。\n\n\nio_uring (异步并发)\n\n\n数据： 55.7k IOPS | 217.6 MB/s\n\n\n解读： 并发魔法。虽然单次 IO 延迟与 Direct IO 相同，但通过 QD=64 的并行提交，吞吐量提升了 8.5倍。\n\n\n\n结论与展望\n核心结论\n本次Phase 1开发验证了以下关键结论：\n\nDirect IO是基准：它直接反映了存储介质的真实性能，避免了Page Cache带来的性能“错觉”\nio_uring具有巨大潜力：在高延迟存储介质上，通过异步并发可以有效提升8.5倍吞吐量\n并发是性能倍增器：单个IO请求的延迟限制被大量并行请求有效“掩盖”了\n架构设计的重要性：面向接口的C语言多态设计使得测试框架具有良好的可扩展性\n\n这些发现为Phase 2的开发提供了坚实的技术基础。\n下一步计划\nPhase 2 (Engine Core) - Bitcask引擎原型：\n\nKV存储引擎实现：基于Bitcask论文，实现一个简单的日志结构键值存储\n多IO模型支持：在Engine Core中同时支持Direct IO、Buffered IO和io_uring\n性能对比测试：在实际KV操作场景中对比不同IO模型的性能表现\n内存管理优化：研究如何更好地利用io_uring的固定缓冲区特性\n\n长期目标：将Kuro-IO发展为Linux存储性能测试的标准工具之一，为开发者和研究人员提供全面的IO性能分析能力。\n\n撰写于2026年1月29日\n项目地址：[GitHub Repository Link TBD]"},"03_Projects/index":{"slug":"03_Projects/index","filePath":"03_Projects/index.md","title":"项目记录","links":[],"tags":["个人","博客"],"content":"这里是项目笔记\n"},"index":{"slug":"index","filePath":"index.md","title":"Welcome","links":[],"tags":["个人","博客"],"content":"嗨各位，我是伏藏。自2025年开始，我将一直在这个博客上更新我的学习笔记和项目记录。\n祝大家玩的开心😋。\n"}}